# HyperFuck 语言

![](https://img.shields.io/badge/Python-3.8-blue) ![](https://img.shields.io/badge/Esoteric-Language-lightgrey) ![](https://img.shields.io/badge/Windows-7%20%2B-orange)

**预览：简单的阶乘**  

```
# 乘法语句块 从栈中取出两个数相乘
Z'{Q[W~QE[vE(Q+WEv)?~Q}

# 如果输入的数字是2、1或0 直接输出
# 如果输入小于0 退出
I%T^^=I?]Tv=IT[|?(I:\0)I<R?(0)I=R?(R^:\0)

# 阶乘 （I=9 U=I-1用于遍历递减 Y=U-1用于条件判断）
U~IUvY~UYvY(U]I]z/I~?UvYv)

# 输出结果
?:\
```

**输入9，输出：**  

```
362880
```

### 虚拟机

HyperFuck运行在基于Python的**虚拟机**上。  

HyperFuck的虚拟机只包括**储存器**、8个**数据寄存器**（qwertyui）和一个**结果寄存器**（?）用于返回值。  

HyperFuck的**符号**包括10个**跳跃符号**（asdfzxcbnm）和6个**引用符号**（ophjkl）。  

HyperFuck允许代码内出现空白或换行。注释必须在新的一行，且以 # 开头。  

### 语法

#### 1. 寄存器

HyperFuck中的寄存器只能**加1减1**、**自增自减**或**加减别的寄存器数据**。  

操作一个寄存器，需要先**选中**，选中的寄存器看作**目标寄存器**；然后输入操作符，后接0个或多个其他寄存器；最后提到的寄存器看作**最后选中的寄存器**。  

| 字符                  | 说明               |
| --------------------- | ------------------ |
| q、w、e ...      | 选中寄存器         |
| ^                     | 加1                |
| v                     | 减1                |
| *                  | 归零            |
| （寄存器）+（寄存器） | 加上别的寄存器数据 |
| （寄存器）-（寄存器） | 减去别的寄存器数据 |
| （寄存器）~（寄存器） | 传送寄存器数据     |

**示例：**

```
q^^w~q^^
```

这段代码首先选中了q寄存器，加2，此时q寄存器为2；选中w寄存器，将q的数据传送到w，此时q和w都为2；因为q是最后提到的寄存器，因此现在选中的寄存器仍是q，将q加2，此时q为4，w为2。  

#### 2. 堆栈与内存

HyperFuck的堆栈不能直接操作，必须移到寄存器中操作。  

| 字符 | 说明 |
| ---- | ---- |
| ]    | 入栈 |
| [    | 出栈 |

执行内存存放HyperFuck的源代码，可以通过指针跳到某处执行。   

允许的跳跃字符有：asdfzxcbnm；跳跃字符支持选中机制；字符可以重复，后者会覆盖前者。  

| 字符      | 说明                                       |
| --------- | ------------------------------------------ |
| （字符）' | 记录此处的语句块                     |
| （字符）/ | 跳到该语句块执行                         |
| {}        | 定义语句块，只有在要求跳跃时执行；不能嵌套 |
| 0         | 退出程序                          |

跳跃指令执行完毕后**会自动跳回来**。  

**示例**

```
z'{q]^^?~q[}
q^^z/q+?
```

此处的z记录了：将q压入栈，将q加2，将q传送到**结果寄存器**，再弹出栈到q。  

主程序：将q加2，跳转到z，将q加上返回的结果。最终，q为6。  

#### 3. 输入输出

| 字符 | 说明                                   |
| ---- | -------------------------------------- |
| .    | 输出寄存器的数字对应的ASCII            |
| :    | 直接输出数字            |
| @    | 从键盘读取字符，转换为数字储存到寄存器 |
| %    | 从键盘读取一个数字                    |
| \    | 换行                                   |
| _    | 清屏                                   |       

#### 4. 逻辑

所有的逻辑运算都将结果保存到**结果寄存器**。  

逻辑运算中的二元运算将**目标寄存器**放在第一位。如 `q>w` 比较的是q是否大于w。  

| 字符 | 说明     |
| ---- | -------- |
| <    | 是否小于 |
| >    | 是否大于 |
| =    | 是否等于 |
| !    | 取反     |
| &    | 与运算   |
| \|   | 或运算   |

使用 `寄存器( ... )` 来循环，循环直到寄存器的值为1。  

使用 （寄存器）` 来跳出一个循环，使用 （寄存器）; 来跳到循环首。  

**示例**

```
q^^w^=q
?!i~?
i(e^^iv)
```

这段代码的意思是：将q增加2，将a增加1。如果q不等于w，就将e增加2。由于 `=` 运算结果只可能为0或1，取反后仍为0或1，所以如果结果为1，只需要减去1，就能让结果变为0。

### 其他语言

由于HyperFuck语言的解释器用Python编写，因此只能调用Python函数。  

在解释HyperFuck时增加参数 `-r （文件名.hi）` 可以让HyperFuck引用Python。   

`.hi` 文件的格式形似：

```
random randint,randascii
foo bar
```

每一行是一个文件，空格后接要引用的函数名。

函数参数必须为 `dict` （寄存器数据字典）和 `list` （栈），可直接对其操作。

允许的引用字符有：ophjkl，按顺序排列；引用字符支持选中机制；如果 `.hi` 文件内的函数超过6个，多余的将被忽略。  

### 命令行工具

#### 1. 交互式

使用 `hyperfuck -i` 可以进入交互模式。  

**示例**

```
C:\Users\Administrator>hyperfuck -i
HyperFuck 1.0 交互式解释器 交互式工具
单独输入1来查看寄存器与堆栈使用。
>>> Q^^]+Q]

>>> 1
 数据    Q=4   W=0   E=0   R=0
寄存器   T=0   Y=0   U=0   I=0
结果寄存器   ?=0

┌──────┐   ┐   ┐
│      │   │   │
│  栈  │ 2 │ 4 │
│      │   │   │
└──────┘   ┘   ┘
>>>
```

#### 2. 解释器

使用 `hyperfuck [options] <主程序>`  解释一个程序。  

如果要引用Python文件，需要添加 `-r <应用索引文件>` 。  

**示例**

```
C:\Users\Administrator>hyperfuck hello.hf
Hello, world!

C:\Users\Administrator>
```

#### 3. 编译器

HyperFuck支持**编译为Python文件**。使用 `hyperfuck [options] -c <主程序>` 编译。  

编译的文件将储存在.compile文件夹内。  